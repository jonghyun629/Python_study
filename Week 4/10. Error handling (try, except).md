# 🔹 1. The Problem Without Handling

If you divide by zero or convert wrong input, Python raises an **exception** and crashes:

```python
x = int("hello")   # ❌ ValueError
print(10 / 0)      # ❌ ZeroDivisionError

```

---

# 🔹 2. Basic `try / except`

You can **catch errors** and handle them gracefully.

```python
try:
    x = int(input("Enter a number: "))
    print(10 / x)
except:
    print("Something went wrong!")

```

👉 If user enters `0` → prints `"Something went wrong!"` instead of crashing.

---

# 🔹 3. Catch Specific Exceptions

Better practice: catch **specific** errors.

```python
try:
    num = int(input("Enter a number: "))
    result = 10 / num
    print(result)
except ValueError:
    print("That was not a valid number.")
except ZeroDivisionError:
    print("You cannot divide by zero.")

```

---

# 🔹 4. `else` with try/except

`else` runs **only if no error happens**.

```python
try:
    x = int(input("Enter a number: "))
    print("You entered:", x)
except ValueError:
    print("Invalid number!")
else:
    print("No errors occurred.")

```

---

# 🔹 5. `finally`

`finally` runs **always**, whether an error occurred or not.

Good for cleanup (like closing a file).

```python
try:
    f = open("data.txt")
    # do something
except FileNotFoundError:
    print("File not found.")
finally:
    print("Closing program.")

```

---

# 🔹 Quick Summary

- **try** → code that may cause error
- **except** → handles the error
- **else** → runs if no error
- **finally** → runs no matter what

---

# 🔹 Practice 📝

1. Ask the user for two numbers and divide them. Handle:
    - `ValueError` if input is not a number
    - `ZeroDivisionError` if dividing by 0
2. Write a program that tries to open `"test.txt"`. If missing, print `"File not found"`, but always print `"Done"` at the end.

---
